import os
import json
from typing import List, Dict, Any, Optional
import requests

class ReportGenerator:
    """
    Main report generator for LANPWNER. Supports JSON and AI-powered HTML reports.
    """
    def __init__(self):
        self.data: Dict[str, Any] = {}

    def add_discovery(self, info: Dict[str, Any]):
        self.data.setdefault('discovery', []).append(info)

    def add_vulnerability(self, vuln: Dict[str, Any]):
        self.data.setdefault('vulnerabilities', []).append(vuln)

    def add_exploitation(self, result: Dict[str, Any]):
        self.data.setdefault('exploitation', []).append(result)

    def generate(self, format: str = 'json', save_path: Optional[str] = None) -> str:
        """
        Generate a report in the specified format. Optionally save to file.
        """
        if format == 'json':
            output = json.dumps(self.data, indent=2)
        elif format == 'html':
            html_gen = HTMLReportGenerator()
            output = html_gen.generate_html_report(self.data)
        else:
            raise ValueError(f"Unsupported report format: {format}")
        if save_path:
            with open(save_path, 'w', encoding='utf-8') as f:
                f.write(output)
        return output

class HTMLReportGenerator:
    """
    Generates a detailed HTML report using Gemini AI, with fallback and post-processing.
    """
    def __init__(self, prompt_file: str = None):
        if prompt_file is None:
            prompt_file = os.path.join(os.path.dirname(__file__), 'gemini_html_prompt.txt')
        self.prompt_file = prompt_file
        self.prompt_template = self._load_prompt_template()
        self.gemini_api_key = os.environ.get('GEMINI_API_KEY', 'YOUR_GEMINI_API_KEY')
        self.gemini_api_url = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent'
        self.branding = '<footer style="text-align:center;margin-top:2em;font-size:small;color:#888;">Report generated by <b>LANPWNER Offensive LAN Framework</b></footer>'
        self.css = '''<style>
body { font-family: Segoe UI, Arial, sans-serif; background: #f8f9fa; color: #222; }
h1, h2, h3 { color: #1a237e; }
table { border-collapse: collapse; width: 100%; margin-bottom: 2em; }
th, td { border: 1px solid #bbb; padding: 8px; }
th { background: #e3e6f3; }
tr:nth-child(even) { background: #f2f2f2; }
pre { background: #eee; padding: 1em; overflow-x: auto; }
section { margin-bottom: 2em; }
.summary-table { margin-bottom: 2em; }
</style>'''

    def _load_prompt_template(self) -> str:
        if os.path.exists(self.prompt_file):
            with open(self.prompt_file, 'r', encoding='utf-8') as f:
                return f.read()
        return """Generate a detailed, professional HTML report for LAN protocol security findings. Include CVEs, remediation, descriptions, titles, and related standards references."""

    def generate_html_report(self, findings: Dict[str, Any]) -> str:
        prompt = self._compose_prompt(findings)
        html_report = self._call_gemini(prompt)
        if not html_report or '<html' not in html_report:
            html_report = self._fallback_html(findings)
        html_report = self._postprocess_html(html_report)
        return html_report

    def _compose_prompt(self, findings: Dict[str, Any]) -> str:
        findings_json = json.dumps(findings, indent=2)
        return self.prompt_template.replace("{{FINDINGS_JSON}}", findings_json)

    def _call_gemini(self, prompt: str) -> str:
        headers = {
            'Content-Type': 'application/json',
        }
        params = {
            'key': self.gemini_api_key
        }
        data = {
            "contents": [
                {"parts": [{"text": prompt}]}
            ]
        }
        try:
            response = requests.post(self.gemini_api_url, headers=headers, params=params, json=data, timeout=60)
            response.raise_for_status()
            result = response.json()
            candidates = result.get('candidates', [])
            if candidates:
                html = candidates[0]['content']['parts'][0]['text']
                return html
            else:
                return ""
        except Exception as e:
            return f"<html><body><h1>Error generating report: {e}</h1></body></html>"

    def _postprocess_html(self, html: str) -> str:
        # Ensure branding and CSS are present
        if '<head>' in html:
            html = html.replace('<head>', f'<head>{self.css}')
        else:
            html = f'<head>{self.css}</head>' + html
        if self.branding not in html:
            html = html.replace('</body>', f'{self.branding}</body>')
        return html

    def _fallback_html(self, findings: Dict[str, Any]) -> str:
        # Fallback: generate a simple but detailed HTML report
        summary = self._generate_summary_table(findings)
        details = self._generate_details(findings)
        return f"""
        <html><head>{self.css}<title>LANPWNER Security Audit Report</title></head>
        <body>
        <h1>LANPWNER Security Audit Report</h1>
        <section><h2>Summary Table</h2>{summary}</section>
        <section><h2>Details</h2>{details}</section>
        {self.branding}
        </body></html>
        """

    def _generate_summary_table(self, findings: Dict[str, Any]) -> str:
        vulns = findings.get('vulnerabilities', [])
        if not vulns:
            return '<p>No vulnerabilities found.</p>'
        rows = ''
        for v in vulns:
            cve = ', '.join(v.get('cve', [])) if isinstance(v.get('cve'), list) else v.get('cve', '')
            rows += f"<tr><td>{v.get('title','')}</td><td>{v.get('protocol','')}</td><td>{cve}</td><td>{v.get('severity','')}</td><td>{v.get('device','')}</td></tr>"
        return f"""
        <table class='summary-table'>
        <tr><th>Title</th><th>Protocol</th><th>CVE</th><th>Severity</th><th>Device/Service</th></tr>
        {rows}
        </table>
        """

    def _generate_details(self, findings: Dict[str, Any]) -> str:
        vulns = findings.get('vulnerabilities', [])
        if not vulns:
            return ''
        html = ''
        for v in vulns:
            cve = ', '.join(v.get('cve', [])) if isinstance(v.get('cve'), list) else v.get('cve', '')
            refs = ''
            if v.get('references'):
                refs = '<ul>' + ''.join(f'<li><a href="{r}" target="_blank">{r}</a></li>' for r in v['references']) + '</ul>'
            html += f"""
            <section>
            <h3>{v.get('title','')}</h3>
            <p><b>Protocol:</b> {v.get('protocol','')}</p>
            <p><b>Device/Service:</b> {v.get('device','')}</p>
            <p><b>CVE(s):</b> {cve}</p>
            <p><b>Severity:</b> {v.get('severity','')}</p>
            <p><b>Description:</b> {v.get('description','')}</p>
            <p><b>Exploitation Evidence:</b> {v.get('evidence','')}</p>
            <p><b>Remediation:</b> {v.get('remediation','')}</p>
            <p><b>Related Standards:</b> {', '.join(v.get('standards', [])) if v.get('standards') else ''}</p>
            <p><b>References:</b> {refs}</p>
            </section>
            """
        return html 